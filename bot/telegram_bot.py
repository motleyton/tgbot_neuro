import logging
import random
from typing import Dict, Set
import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, \
    filters, ContextTypes, CallbackContext, CallbackQueryHandler
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from database_helper import Database
from utils import error_handler
from openai_helper import localized_text, OpenAI
import fasttext
from file_sender import FileSender


class ChatGPTTelegramBot:
    """
    A Telegram bot integrated with OpenAI's GPT model and capable of sending automated files.

    Attributes:
        config (dict): Configuration dictionary containing necessary keys and tokens.
        openai (OpenAI): The OpenAI GPT instance for generating text responses.
        db (Database): Instance of the Database class for data retrieval and management.
        allowed_usernames (list): List of Telegram usernames allowed to interact with the bot.
        user_languages (dict): Dictionary to store users' language preferences.
        stickers_ids (str): Path to a file containing sticker IDs for the bot to send.
        bot (Bot): The Telegram Bot instance.
        file_sender (FileSender): An instance of FileSender for handling file-related operations.
        service (Resource): Google API service resource for accessing Drive API.
        active_users (set): A set of active user IDs that have interacted with the bot.
        counter (int): A counter used for iterating through files to send.
    """

    def __init__(self, config: Dict, openai: OpenAI):
        self.config = config
        self.openai = openai
        self.db = Database(config)
        self.file_id_users = config['users']
        self.allowed_usernames = self.db.get_usernames(self.file_id_users)
        self.user_languages: Dict[int, str] = {}
        self.stickers_ids = config['stickers_ids']
        self.model = fasttext.load_model('lid.176.bin')
        self.bot = telegram.Bot(token=config['token'])
        self.file_sender = FileSender()
        self.scopes = ['https://www.googleapis.com/auth/drive']
        self.service = self.file_sender.oauth(self.scopes, self.config['service_account'])
        self.checklists_folder_jpg_rus = config['checklists_folder_jpg_rus']
        self.checklists_folder_jpg_uz = config['checklists_folder_jpg_uz']
        self.checklists_folder_pdf_rus = config['checklists_folder_pdf_rus']
        self.checklists_folder_pdf_uz = config['checklists_folder_pdf_uz']
        self.checklists_file_id_text_rus = config['checklists_file_id_text_rus']
        self.checklists_file_id_text_uz = config['checklists_file_id_text_uz']
        self.active_users: Set[int] = set()
        self.counter = 1

    async def start(self, update: Update, context: CallbackContext) -> None:
        """
        Sends a welcome message and asks the user to select a language.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.effective_user.id
        self.active_users.add(user_id)
        bot_language = self.config['bot_language']
        username = "@" + update.message.from_user.username if update.message.from_user.username else None
        disallowed = (
            localized_text('disallowed', bot_language))
        if username not in self.allowed_usernames:
            await update.message.reply_text(disallowed, disable_web_page_preview=True)
            return

        welcome_message = "–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Salom! Tilni tanlang."
        keyboard = [
            [
                InlineKeyboardButton("–†—É—Å—Å–∫–∏–π", callback_data='ru'),
                InlineKeyboardButton("Uzbek", callback_data='uz')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(welcome_message, reply_markup=reply_markup)

    async def button(self, update: Update, context: CallbackContext) -> None:
        """
        Handles language selection buttons and updates user language preference.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        query = update.callback_query
        await query.answer()
        language = query.data  # 'ru' –∏–ª–∏ 'uz'
        user_id = update.effective_user.id

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫ –≤ —Å–ª–æ–≤–∞—Ä–µ user_languages
        self.user_languages[user_id] = language
        welcome_message_rus = ''' 
          –í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫.\n\n–ê —Ç–µ–ø–µ—Ä—å —Ä–∞—Å—Å–∫–∞–∂–µ–º –ø—Ä–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞. üßô‚Äç‚ôÇÔ∏è –≠—Ç–æ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –Ω–µ–π—Ä–æ-—Ç—å—é—Ç–æ—Ä. –ï–º—É –º–æ–∂–Ω–æ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ —É—Ä–æ–∫–∞–º. \n\n–ö–∞–∂–¥—ã–π –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –≤ 12:00 –≤–∞–º –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏ –æ—Ç –±–æ—Ç–∞ —Å –ø–æ–ª–µ–∑–Ω—ã–º–∏ –ø–∞–º—è—Ç–∫–∞–º–∏ –∏ —á–µ–∫-–ª–∏—Å—Ç–∞–º–∏üå∏ \n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–µ–π—á–∞—Å —Å–ø—Ä–æ—Å–∏—Ç—å, —á—Ç–æ —Ç–∞–∫–æ–µ —Ç–∞—Ä–≥–µ—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–µ–∫–ª–∞–º–∞.\n\n–í–æ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ –í–∞–º –∫–æ–º–∞–Ω–¥—ã:\n\nüîò–ù–∞—á–∞—Ç—å: –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞.\n\nüîò–ü–æ–º–æ—â—å: –ü–æ–ª—É—á–∏—Ç–µ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\nüîò–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∫—É—Ä—Å–∞: –ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–∞–∑–¥–µ–ª—ã –∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –∫—É—Ä—Å–∞.
          '''

        welcome_message_uz = '''
          Siz rus tilini tanladingiz.\n\nEndi botning imkoniyatlari haqida gapiraylik. üßô‚Äç‚ôÇÔ∏è Bu sizning shaxsiy neyro-o‚Äôqituvchingiz. Unga darslar haqida savollar berishingiz mumkin. \n\nHar dushanba kuni soat 12:00 da siz botdan foydali eslatmalar va nazorat varaqlari bilan sovg'a olasizüå∏ \n\nEndi maqsadli reklama nima ekanligini so ªrab ko ªring.\n\nMana siz uchun mavjud buyruqlar:\n\nüîòBoshlash: Botdan qayta foydalanishni boshlash uchun bosing.\n\nüîòYordam: Ma'lumot xabarini oling.\n\nüîòKurs tarkibi: Kursning mavjud bo'limlari va materiallarini ko'rib chiqing.
          '''

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —è–∑—ã–∫–µ
        if language == 'ru':
            confirmation_message = welcome_message_rus
            commands = ["/–ù–∞—á–∞—Ç—å", "/–ü–æ–º–æ—â—å", "/–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∫—É—Ä—Å–∞"]
            command_callbacks = ["/start", "/help", "/course_content"]

        elif language == 'uz':
            confirmation_message = welcome_message_uz
            commands = ["/ Boshlash", "/ Yordam", "/ Kurs_tarkibi"]
            command_callbacks = ["/start", "/help", "/course_content"]

        commands_keyboard = [[KeyboardButton(cmd)] for cmd in commands]
        commands_markup = ReplyKeyboardMarkup(commands_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await query.edit_message_text(text=confirmation_message)
        await query.message.delete()

        await context.bot.send_message(chat_id=user_id, text=confirmation_message, reply_markup=commands_markup)

        # –û–±–Ω–æ–≤–ª—è–µ–º —è–∑—ã–∫ –±–æ—Ç–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        self.config['bot_language'] = language


    async def help(self, update: Update, context: CallbackContext) -> None:
        """
        Sends a help message to the user.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.message.from_user.id
        username = "@" + update.message.from_user.username if update.message.from_user.username else None

        # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è; –∏—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —è–∑—ã–∫
        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))

        if username not in self.allowed_usernames:
            disallowed = localized_text('disallowed', user_language)
            await update.message.reply_text(disallowed, disable_web_page_preview=True)
            return

        help_texts = localized_text('help_text', user_language)
        help_message = "\n".join(help_texts)  # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ–º–æ—â–∏ –≤ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await update.message.reply_text(help_message, disable_web_page_preview=True)

    async def message_handler(self, update: Update, context: CallbackContext) -> None:
        """
        Handles incoming messages and responds accordingly.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.message.from_user.id
        user_message = update.message.text

        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))

        if user_language == 'ru':
            if user_message == '/–ù–∞—á–∞—Ç—å':
                await self.start(update, context)
            elif user_message == '/–ü–æ–º–æ—â—å':
                await self.help(update, context)
            elif user_message == '/–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∫—É—Ä—Å–∞':
                await self.course_content(update, context)

        elif user_language == 'uz':
            if user_message == '/ Boshlash':
                await self.start(update, context)
            elif user_message == '/ Yordam':
                await self.help(update, context)
            elif user_message == '/ Kurs_tarkibi':
                await self.course_content(update, context)

        if user_message.startswith('/'):
            return

        try:
            predictions = self.model.predict(user_message, k=1)  # k=1 –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–∞–º—ã–π –≤–µ—Ä–æ—è—Ç–Ω—ã–π —è–∑—ã–∫
            detected_language = predictions[0][0].replace("__label__", "")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —è–∑—ã–∫–∞: {e}")
            await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —è–∑—ã–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è.")
            return

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —è–∑—ã–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —è–∑—ã–∫–∞
        if detected_language != user_language:
            error_message = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–≤–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ." if user_language == 'ru' else "Iltimos, savollaringizni o'zbek tilida bering."
            await update.message.reply_text(error_message)
            return

        processing_message = "–ü–æ–∫–∞ –≤–∞—à –∑–∞–ø—Ä–æ—Å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è, –ª–æ–≤–∏—Ç–µ –∫–æ—Ç–∏–∫–∞ \n\n*–û–±—Ä–∞—â–∞–µ–º –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –º–æ–∂–µ—Ç –∑–∞–Ω–∏–º–∞—Ç—å –≤—Ä–µ–º—è –¥–æ 1 –º–∏–Ω—É—Ç—ã " if user_language == 'ru' \
            else "Hozircha so‚Äôrovingiz ko‚Äôrib chiqilmoqda, mushukchani tuting \n\n*Diqqat qiling, javobni tayyorlash bir daqiqagacha vaqt olishi mumkin"
        processing_message_id = await update.message.reply_text(processing_message)

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞
        try:
            with open(self.stickers_ids, 'r') as file:
                stickers = file.readlines()
                stickers = [line.strip() for line in stickers if line.strip()]
                sticker_file_id = random.choice(stickers)  # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ file_id
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ —Å—Ç–∏–∫–µ—Ä–æ–≤: {e}")
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞.")
            return

        await update.message.reply_sticker(sticker=sticker_file_id)

        qa_chain = self.openai.initialize_chat()
        response = qa_chain.run(user_message)
        await update.message.reply_text(response)

    async def course_content(self, update: Update, context: CallbackContext) -> None:
        """
        Sends the course content to the user, if they are allowed to access it.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.effective_user.id
        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))
        username = "@" + update.message.from_user.username if update.message.from_user.username else None

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–∞–∑—Ä–µ—à—ë–Ω –ª–∏ –¥–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        if username not in self.allowed_usernames:
            disallowed_message = localized_text('disallowed', self.config['bot_language'])
            await update.message.reply_text(disallowed_message, disable_web_page_preview=True)
            return

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –∫—É—Ä—Å–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        content = self.db.get_course_content(language=user_language)
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç, —É—á–∏—Ç—ã–≤–∞—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ Telegram –Ω–∞ —Ä–∞–∑–º–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è
        await update.message.reply_text(content[:4096])

    async def send_files_by_counter(self, service) -> None:
        global counter

        if self.counter > 8:  # –ï—Å–ª–∏ —Å—á–µ—Ç—á–∏–∫ –ø—Ä–µ–≤—ã—Å–∏–ª –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤, –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            return

        for user_id in self.active_users:
            try:
                chat = await self.bot.get_chat(user_id)
                username = "@" + chat.username if chat.username else None

                if username not in self.allowed_usernames:
                    continue

                user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))
                jpg_folder_id, pdf_folder_id = self.get_folder_ids(user_language)
                checklists_text = self.get_checklists_text(user_language)
                jpg_files, pdf_files = self.get_files(service, jpg_folder_id, pdf_folder_id)

                text = await self.file_sender.download_file(service, checklists_text, is_google_doc=True)
                caption_text_dict = self.file_sender.extract_sections(text) if text else {}
                caption_text = caption_text_dict.get(str(self.counter), "–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")

                selected_files = [f for f in jpg_files + pdf_files if f['name'].startswith(str(self.counter))]

                all_files_sent = True  # –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤
                for file in selected_files:
                    file_stream = await self.file_sender.download_file(service, file['id'], is_google_doc=False)
                    success = await self.send_file(user_id, file, file_stream, caption_text)
                    if not success:
                        all_files_sent = False  # –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –≤ False

                if all_files_sent:
                    print(f"Files for counter {self.counter} were successfully sent to user {user_id}.")
                else:
                    print(f"Not all files for counter {self.counter} were sent successfully to user {user_id}.")

            except Exception as e:
                print(f"Error processing user {user_id}: {e}")

        self.counter += 1  # –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—á–µ—Ç—á–∏–∫ –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

    def get_folder_ids(self, user_language):
        jpg_folder_id = self.checklists_folder_jpg_rus if user_language == 'ru' else self.checklists_folder_jpg_uz
        pdf_folder_id = self.checklists_folder_pdf_rus if user_language == 'ru' else self.checklists_folder_pdf_uz
        return jpg_folder_id, pdf_folder_id

    def get_checklists_text(self, user_language):
        return self.checklists_file_id_text_rus if user_language == 'ru' else self.checklists_file_id_text_uz

    def get_files(self, service, jpg_folder_id, pdf_folder_id):
        jpg_files = self.db.list_files_in_folder(service, jpg_folder_id)
        pdf_files = self.db.list_files_in_folder(service, pdf_folder_id)
        return jpg_files, pdf_files

    async def send_file(self, user_id, file, file_stream, caption_text):
        try:
            if file['name'].endswith('.jpg'):
                file_stream.seek(0)
                await self.bot.send_photo(chat_id=user_id, photo=file_stream, caption=caption_text)
            elif file['name'].endswith('.pdf'):
                file_stream.seek(0)
                await self.bot.send_document(chat_id=user_id, document=file_stream, filename=file['name'])
            return True  # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω
        except Exception as e:
            print(f"Failed to send file {file['name']} to user {user_id}: {e}")
            return False  # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç False, –µ—Å–ª–∏ –≤–æ –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞

    def start_scheduler(self) -> None:
        """
        Starts the APScheduler to periodically execute tasks.
        """

        scheduler = AsyncIOScheduler()
        scheduler.add_job(self.send_files_by_counter, 'interval', seconds=120, args=[self.service])
        scheduler.start()

    def run(self) -> None:
        """
        Initiates the bot and starts polling for updates.
        """

        application = ApplicationBuilder() \
            .token(self.config['token']) \
            .concurrent_updates(True) \
            .build()

        application.add_handler(CommandHandler('start', self.start))
        application.add_handler(CommandHandler('help', self.help))
        application.add_handler(CommandHandler('course_content', self.course_content))
        application.add_handler(CallbackQueryHandler(self.button))
        application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), self.message_handler))
        application.add_error_handler(error_handler)
        self.start_scheduler()

        application.run_polling()
