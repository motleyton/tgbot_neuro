import logging
import random
from typing import Dict, Set
import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, \
    filters, ContextTypes, CallbackContext, CallbackQueryHandler
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from database_helper import Database
from utils import error_handler
from openai_helper import localized_text, OpenAI
import fasttext
from file_sender import FileSender

class ChatGPTTelegramBot:
    """
    A Telegram bot integrated with OpenAI's GPT model and capable of sending automated files.

    Attributes:
        config (dict): Configuration dictionary containing necessary keys and tokens.
        openai (OpenAI): The OpenAI GPT instance for generating text responses.
        db (Database): Instance of the Database class for data retrieval and management.
        allowed_usernames (list): List of Telegram usernames allowed to interact with the bot.
        user_languages (dict): Dictionary to store users' language preferences.
        stickers_ids (str): Path to a file containing sticker IDs for the bot to send.
        bot (Bot): The Telegram Bot instance.
        file_sender (FileSender): An instance of FileSender for handling file-related operations.
        service (Resource): Google API service resource for accessing Drive API.
        active_users (set): A set of active user IDs that have interacted with the bot.
        counter (int): A counter used for iterating through files to send.
    """

    def __init__(self, config: Dict, openai: OpenAI):
        self.config = config
        self.openai = openai
        self.db = Database(config)
        self.file_id_users = config['users']
        self.allowed_usernames = self.db.get_usernames(self.file_id_users)
        self.user_languages: Dict[int, str] = {}
        self.stickers_ids = config['stickers_ids']
        self.model = fasttext.load_model('lid.176.bin')
        self.bot = telegram.Bot(token=config['token'])
        self.file_sender = FileSender()
        self.scopes = ['https://www.googleapis.com/auth/drive']
        self.service = self.file_sender.oauth(self.scopes, self.config['service_account'])
        self.checklists_folder_jpg_rus = config['checklists_folder_jpg_rus']
        self.checklists_folder_jpg_uz = config['checklists_folder_jpg_uz']
        self.checklists_folder_pdf_rus = config['checklists_folder_pdf_rus']
        self.checklists_folder_pdf_uz = config['checklists_folder_pdf_uz']
        self.checklists_file_id_text_rus = config['checklists_file_id_text_rus']
        self.checklists_file_id_text_uz = config['checklists_file_id_text_uz']
        self.active_users: Set[int] = set()
        self.counter = 1

    async def start(self, update: Update, context: CallbackContext) -> None:
        """
        Sends a welcome message and asks the user to select a language.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.effective_user.id
        self.active_users.add(user_id)
        bot_language = self.config['bot_language']
        username = "@" + update.message.from_user.username if update.message.from_user.username else None
        disallowed = (
            localized_text('disallowed', bot_language))
        if username not in self.allowed_usernames:
            await update.message.reply_text(disallowed, disable_web_page_preview=True)
            return

        welcome_message = "–ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Salom! Tilni tanlang."
        keyboard = [
            [
                InlineKeyboardButton("–†—É—Å—Å–∫–∏–π", callback_data='ru'),
                InlineKeyboardButton("–£–∑–±–µ–∫—Å–∫–∏–π", callback_data='uz')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(welcome_message, reply_markup=reply_markup)

    async def button(self, update: Update, context: CallbackContext) -> None:
        """
        Handles language selection buttons and updates user language preference.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        query = update.callback_query
        await query.answer()
        language = query.data  # 'ru' –∏–ª–∏ 'uz'
        user_id = update.effective_user.id

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫ –≤ —Å–ª–æ–≤–∞—Ä–µ user_languages
        self.user_languages[user_id] = language
        welcome_message_rus = ''' 
        –í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫. –ê —Ç–µ–ø–µ—Ä—å —Ä–∞—Å—Å–∫–∞–∂–µ–º –ø—Ä–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞. üßô‚Äç‚ôÇÔ∏è –≠—Ç–æ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –Ω–µ–π—Ä–æ-—Ç—å—é—Ç–æ—Ä. –ï–º—É –º–æ–∂–Ω–æ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ —É—Ä–æ–∫–∞–º. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –±–æ—Ç –±—É–¥–µ—Ç –¥–∞—Ä–∏—Ç—å –≤–∞–º –ø–æ–ª–µ–∑–Ω—ã–µ –ø–∞–º—è—Ç–∫–∏ –∏ —Å—Å—ã–ª–∫–∏. üå∏ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–µ–π—á–∞—Å —Å–ø—Ä–æ—Å–∏—Ç—å, —á—Ç–æ —Ç–∞–∫–æ–µ —Ç–∞—Ä–≥–µ—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–µ–∫–ª–∞–º–∞.
        '''

        welcome_message_uz = '''
        Siz rus tilini tanladingiz. Endi botning imkoniyatlari haqida gapiraylik. üßô‚Äç‚ôÇÔ∏è Bu sizning shaxsiy neyro-o‚Äôqituvchingiz. Unga darslar haqida savollar berishingiz mumkin. Bundan tashqari, bot sizga foydali eslatmalar va havolalar beradi. üå∏ Endi maqsadli reklama nima ekanligini so ªrab ko ªring.
        '''

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —è–∑—ã–∫–µ
        if language == 'ru':
            confirmation_message = welcome_message_rus
        elif language == 'uz':
            confirmation_message = welcome_message_uz
        await query.edit_message_text(text=confirmation_message)

        # –û–±–Ω–æ–≤–ª—è–µ–º —è–∑—ã–∫ –±–æ—Ç–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        self.config['bot_language'] = language

    async def help(self, update: Update, context: CallbackContext) -> None:
        """
        Sends a help message to the user.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """
        
        user_id = update.message.from_user.id
        username = "@" + update.message.from_user.username if update.message.from_user.username else None

        # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è; –∏—Å–ø–æ–ª—å–∑—É–µ–º —è–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —è–∑—ã–∫
        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))

        if username not in self.allowed_usernames:
            disallowed = localized_text('disallowed', user_language)
            await update.message.reply_text(disallowed, disable_web_page_preview=True)
            return

        help_texts = localized_text('help_text', user_language)
        help_message = "\n".join(help_texts)  # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ–º–æ—â–∏ –≤ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await update.message.reply_text(help_message, disable_web_page_preview=True)

    async def message_handler(self, update: Update, context: CallbackContext) -> None:
        """
        Handles incoming messages and responds accordingly.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.message.from_user.id
        user_message = update.message.text
        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))

        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º FastText
        try:
            predictions = self.model.predict(user_message, k=1)  # k=1 –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–∞–º—ã–π –≤–µ—Ä–æ—è—Ç–Ω—ã–π —è–∑—ã–∫
            detected_language = predictions[0][0].replace("__label__", "")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —è–∑—ã–∫–∞: {e}")
            await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —è–∑—ã–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è.")
            return

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —è–∑—ã–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —è–∑—ã–∫–∞
        if detected_language != user_language:
            error_message = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–≤–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ." if user_language == 'ru' else "Iltimos, savollaringizni o'zbek tilida bering."
            await update.message.reply_text(error_message)
            return

        processing_message = "–ü–æ–∫–∞ –≤–∞—à –∑–∞–ø—Ä–æ—Å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è, –ª–æ–≤–∏—Ç–µ –∫–æ—Ç–∏–∫–∞" if user_language == 'ru' \
            else "Hozircha so‚Äôrovingiz ko‚Äôrib chiqilmoqda, mushukchani tuting"
        processing_message_id = await update.message.reply_text(processing_message)

        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞
        try:
            with open(self.stickers_ids, 'r') as file:
                stickers = file.readlines()
                stickers = [line.strip() for line in stickers if line.strip()]
                sticker_file_id = random.choice(stickers)  # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ file_id
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ —Å—Ç–∏–∫–µ—Ä–æ–≤: {e}")
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞.")
            return

        await update.message.reply_sticker(sticker=sticker_file_id)

        qa_chain = self.openai.initialize_chat()
        response = qa_chain.run(user_message)
        await update.message.reply_text(response)

    async def course_content(self, update: Update, context: CallbackContext) -> None:
        """
        Sends the course content to the user.

        Args:
            update (Update): The incoming update.
            context (CallbackContext): The context of the callback.
        """

        user_id = update.effective_user.id
        user_language = self.user_languages.get(user_id, self.config.get('default_language', 'ru'))

        # –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–∞—à Database –∫–ª–∞—Å—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –∫—É—Ä—Å–∞
        content = self.db.get_course_content(language=user_language)
        await update.message.reply_text(content[:4096])  # Telegram –∏–º–µ–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤ 4096 —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ

    async def send_files_by_counter(self, service) -> None:
        """
        Sends files to users based on a counter which iterates through the files.

        Args:
            service: The Google Drive API service instance.
        """

        caption_text_dict = {}
        global counter
        for user_id in self.active_users:

            user_language = self.user_languages.get(user_id, self.config.get('default_language'))


            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ ID –ø–∞–ø–æ–∫ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞
            jpg_folder_id = self.checklists_folder_jpg_rus if user_language == 'ru' else self.checklists_folder_jpg_uz
            pdf_folder_id = self.checklists_folder_pdf_rus if user_language == 'ru' else self.checklists_folder_pdf_uz
            checklists_text = self.checklists_file_id_text_rus if user_language == 'ru' else self.checklists_file_id_text_uz
            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∏–∑ –ø–∞–ø–æ–∫
            jpg_files = self.db.list_files_in_folder(service, jpg_folder_id)
            pdf_files = self.db.list_files_in_folder(service, pdf_folder_id)
            try:
                # –ó–∞–≥—Ä—É–∑–∫–∞ –∏ —Ä–∞–∑–±–æ—Ä —Ç–µ–∫—Å—Ç–∞
                text = await self.file_sender.download_file(service, checklists_text, is_google_doc=True)
                caption_text_dict = self.file_sender.extract_sections(text) if text else {}
            except Exception as e:
                print(f"Error downloading or parsing text: {e}")

            caption_text = caption_text_dict.get(str(self.counter), "–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")

            selected_files = [f for f in jpg_files + pdf_files if f['name'].startswith(str(self.counter))]

            for file in selected_files:
                file_stream = await self.file_sender.download_file(service, file['id'], is_google_doc=False)

                if file['name'].endswith('.jpg'):
                    file_stream.seek(0)
                    await self.bot.send_photo(chat_id=user_id, photo=file_stream, caption=caption_text)
                elif file['name'].endswith('.pdf'):
                    file_stream.seek(0)
                    await self.bot.send_document(chat_id=user_id, document=file_stream, filename=file['name'])

        if caption_text_dict:
            self.counter = (self.counter % len(caption_text_dict)) + 1
        else:
            self.counter += 1

    def start_scheduler(self) -> None:
        """
        Starts the APScheduler to periodically execute tasks.
        """

        scheduler = AsyncIOScheduler()
        scheduler.add_job(self.send_files_by_counter, 'interval', seconds=20, args=[self.service])
        scheduler.start()

    def run(self) -> None:
        """
        Initiates the bot and starts polling for updates.
        """

        application = ApplicationBuilder() \
            .token(self.config['token']) \
            .concurrent_updates(True) \
            .build()

        application.add_handler(CommandHandler('start', self.start))
        application.add_handler(CommandHandler('help', self.help))
        application.add_handler(CommandHandler('course_content', self.course_content))
        application.add_handler(CallbackQueryHandler(self.button))
        application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), self.message_handler))

        application.add_error_handler(error_handler)
        self.start_scheduler()

        application.run_polling()